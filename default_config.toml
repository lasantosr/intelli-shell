# This file contains the default configuration settings for Intelli-Shell.
# It serves as both a demo of available options and a reference for customization.
#
# To customize your configuration, copy this file to your user configuration directory or create a new one:
# ~/.config/intelli-shell/config.toml (on Linux)
# ~/Library/Application Support/org.IntelliShell.Intelli-Shell/config.toml (on macOS)
# %APPDATA%\IntelliShell\Intelli-Shell\config\config.toml (on Windows)
# $XDG_CONFIG_HOME/intelli-shell/config.toml (if XDG_CONFIG_HOME is set)
#
# Any setting not present on the file will inherit the default value displayed here.

# --------------------------------------------------------------
#   General 
# --------------------------------------------------------------

# The default directory for application data, such as the stored commands database.
# If this value is left empty, the application will use the system's default data directory:
# - ~/.local/share/intelli-shell (on Linux, unless overridden by XDG_DATA_HOME)
# - ~/Library/Application Support/org.IntelliShell.Intelli-Shell (on macOS)
# - %APPDATA%\IntelliShell\Intelli-Shell\data (on Windows)
data_dir = ""

# Whether to check for updates on application startup
check_updates = true

# Determines the rendering mode for the Terminal User Interface (TUI).
# - If `true`, the TUI will appear directly below the shell prompt, integrating seamlessly
# - If `false`, the TUI will take over the entire terminal screen
inline = true

# --------------------------------------------------------------
#   Gist Integration
# --------------------------------------------------------------

# Configuration for the default gist to use when importing or exporting (if no other is explicitly set)
[gist]
# The id of the gist, you can get it from the url after the username
id = ""
# Token to authenticate the API call to GH when exporting
# GIST_TOKEN env variable will take precedence over the config value
token = ""

# --------------------------------------------------------------
#   Search Command 
# --------------------------------------------------------------

# Configuration for the search command
[search]
# The delay (in ms) to wait and accumulate type events before triggering the query
delay = 250
# Specifies the default search mode to be used when initiating a search.
# Possible values are:
# - "auto": An internal algorithm is used to best match common human search patterns
# - "fuzzy": Employs fuzzy matching to find commands that are similar to the input query
# - "regex": Treats the input query as a regular expression, allowing for complex pattern matching
# - "exact": The search will only return commands that precisely match the entire input query
# - "relaxed": Attempts to find the maximum number of potentially relevant commands using broader matching criteria
mode = "auto"
# Whether to search for user commands only by default when initiating a search (excluding tldr and workspace)
user_only = false
# Whether to directly execute the command if it matches an alias exactly, instead of just selecting
exec_on_alias_match = false

# --------------------------------------------------------------
#   Logs 
# --------------------------------------------------------------

# Configuration settings for application logging.
#
# If an `INTELLI_LOG` environment variable exists, it will override the filter and enable logging.
[logs]
# Whether application logging is enabled.
# If set to `true`, the application will write detailed logs to a file within the data directory.
enabled = false
# The log filter to apply, controlling which logs are recorded.
#
# This string supports the `tracing-subscriber`'s environment filter syntax, for example:
# - "info" enables info log level (and above: warn and error)
# - "warn,intelli_shell=debug" enables debug for `intelli_shell` and warn for the rest
filter = "info"

# --------------------------------------------------------------
#   Key Bindings
# --------------------------------------------------------------

# Configuration for the key bindings used to interact with the Terminal User Interface (TUI).
# Key bindings map an action within the application to one or more key press combinations.
#
# Each action can be bound to a single key event string or a list of key event strings.
# If a list is provided, pressing any of the listed combinations will trigger the action.
#
# Key event strings are parsed from a simple format:
# - Modifiers (optional, separated by `-` or `+`): `ctrl`, `shift`, `alt`
# - Followed by the key name or character
[keybindings]
# Exit the TUI gracefully
quit = "esc"
# Update the currently highlighted record or item (e.g., edit a command)
update = ["ctrl-u", "ctrl-e", "F2"]
# Delete the currently highlighted record or item
delete = "ctrl-d"
# Confirm a selection or action related to the highlighted record
confirm = ["tab", "enter"]
# Execute the action associated with the highlighted record or item (e.g., run a command)
execute = ["ctrl-enter", "ctrl-r"]
# Prompt ai about suggestions (e.g. when searching for commands)
ai = ["ctrl-i", "ctrl-x"]
# Toggle the search mode
search_mode = "ctrl-s"
# Toggle whether to search for user commands only or include workspace and tldr's
search_user_only = "ctrl-o"

# --------------------------------------------------------------
#   Theme
# --------------------------------------------------------------

# Configuration for the visual theme of the Terminal User Interface (TUI).
#
# Styles are defined using a string that can consist of one or more optional modifiers
# followed by an optional color. Modifiers and colors should be space-separated.
#
# Supported Modifiers: `bold`, `dim`, `italic`, `underline`
#
# Supported Color Formats:
# - Keep the original terminal color (no ANSI escape codes): "default" or an empty string (`""`)
# - Named colors (standard ANSI): "black", "red", etc.
# - RGB color value: "rgb(15, 15, 15)"
# - Hexadecimal color value: "#112233"
# - ANSI 8-bit indexed color (integer string from 0 to 255): "8", "13", etc.
[theme]
# The primary style used for main elements, like selected items or important text
primary = "default"
# The secondary style used for less prominent elements, like unselected items
secondary = "dim"
# An accent style used to highlight specific elements, like aliases or keywords
accent = "yellow"
# The style used for comments or explanatory text
comment = "italic green"
# The style used for errors
error = "dark red"
# The background color for the highlighted item in a list. Use "none" for no background color
highlight = "darkgrey"
# The string symbol displayed next to the highlighted item
highlight_symbol = "Â» "
# The primary style applied specifically to a highlighted item
highlight_primary = "default"
# The secondary style applied specifically to a highlighted item
highlight_secondary = "default"
# The accent style applied specifically to a highlighted item
highlight_accent = "yellow"
# The comments style applied specifically to a highlighted item
highlight_comment = "italic green"

# --------------------------------------------------------------
#   Search Tuning
# --------------------------------------------------------------

# Configuration to tune the variables suggestion ranking algorithm.
#
# The final score for a variable suggestion is a weighted sum of points from three sources:
# 1. Completion Score: The value is present on the dynamic completions for the variable
# 2. Context Score: Other variable values already selected to the command
# 3. Path Score: Where the value has been used before
# The total usage will be used as a tie-breaker if the same points are scored
[tuning.variables]
# Total points assigned for being present on dynamic variable completions
completion.points = 200

# Total points assigned for matching contextual information (e.g., previous variables values)
context.points = 700

# Total points assigned for matching any usage on a relevant path
path.points = 300
# Weights applied to a variable path score based on where it was used
path.exact = 1.0
path.ancestor = 0.5
path.descendant = 0.25
path.unrelated = 0.1

# Configuration to tune the command search ranking algorithm.
#
# The final score for a command is a weighted sum of points from three sources:
# 1. Usage Score: How often the command has been globally used
# 2. Path Score: Where the command has been used before
# 3. Text Relevance: How well the command's text matches the search query (if any)
[tuning.commands]
# Total points assigned to the global usage of a command
usage.points = 100

# Total points assigned for matching any usage on a relevant path
path.points = 300
# Weights applied to a command path points based on where it was used
path.exact = 1.0
path.ancestor = 0.5
path.descendant = 0.25
path.unrelated = 0.1

# Total points assigned to the normalized text relevance score
text.points = 600
# The weight for the command's `cmd` field in the text search
text.command = 2.0
# The weight for the command's `description` field in the text search
text.description = 1.0

# --- "auto" Mode Specific Tuning ---
# Multiplier for high-confidence prefix matches
text.auto.prefix = 1.5
# Multiplier for standard "all words must match" fuzzy results
text.auto.fuzzy = 1.0
# Multiplier for lower-confidence "any word can match" relaxed results
text.auto.relaxed = 0.5
# A boost multiplier to add when the search term matches the start of a command
text.auto.root = 2.0

# --------------------------------------------------------------
#   AI Integration
# --------------------------------------------------------------

# Configures all AI-powered features, such as command suggestions, error correction, and automated command imports.
#
# This section is organized into three main parts:
# 1. Task Assignment: Assign a model alias to a specific task, like `suggest` or `fix`
# 2. Model Catalog: Define the details for each model alias used in the task assignment
# 3. Custom Prompts: Fine-tune the instruction templates sent to the AI for each task
[ai]
# A global switch to enable or disable all AI-powered functionality
enabled = false

# --- Task Assignment ---
# Assign models to tasks by their alias (which must be defined in the Model Catalog below)
[ai.models]
# The alias of the model to use for generating command templates from natural language
suggest = "main"
# The alias of the model used to fix or explain a failing command
fix = "main"
# The alias of the model to use when importing commands
import = "main"
# The alias of the model to use when generating a command for a dynamic variable completion
completion = "main"
# The alias of a model to use as a fallback if the primary model fails due to rate limits
fallback = "fallback"

# --- Model Catalog ---
# This is where you define the specific configuration for each AI model alias used above.
#
# Supported Providers and Default API Key Environment Variables:
# - "openai":    OPENAI_API_KEY
# - "gemini":    GEMINI_API_KEY
# - "anthropic": ANTHROPIC_API_KEY
# - "ollama":    OLLAMA_API_KEY (often not required for local instances)

[ai.catalog.main]
provider = "gemini"
model = "gemini-flash-latest"

[ai.catalog.fallback]
provider = "gemini"
model = "gemini-flash-lite-latest"

# --- AI Prompts ---
# This section allows for the customization of the prompts sent to the AI for different tasks.
# You can modify the text to better suit your needs or instruct the AI to behave differently.
#
# The following placeholders are available and will be replaced with contextual information before the prompt is sent to the model:
# - ##OS_SHELL_INFO##: Replaced with details about the current operating system and shell
# - ##WORKING_DIR##: Replaced with the current working directory, including a tree-like view of its immediate contents
# - ##SHELL_HISTORY##: Replaced with the last few commands from the shell history (only available for the `fix` prompt)
[ai.prompts]
# Prompt used to generate command templates from natural language
suggest = """
##OS_SHELL_INFO##
##WORKING_DIR##
### Instructions
You are an expert CLI assistant. Your task is to generate shell command templates based on the user's request.

Your entire response MUST be a single, valid JSON object conforming to the provided schema and nothing else.

### Shell Paradigm, Syntax, and Versioning
**This is the most important instruction.** Shells have fundamentally different syntaxes, data models, and features depending on their family and version. You MUST adhere strictly to these constraints.

1. **Recognize the Shell Paradigm:**
   - **POSIX / Text-Stream (bash, zsh, fish):** Operate on **text streams**. Use tools like `grep`, `sed`, `awk`.
   - **Object-Pipeline (PowerShell, Nushell):** Operate on **structured data (objects)**. You MUST use internal commands for filtering/selection. AVOID external text-processing tools.
   - **Legacy (cmd.exe):** Has unique syntax for loops (`FOR`), variables (`%VAR%`), and filtering (`findstr`).

2. **Generate Idiomatic Code:**
   - Use the shell's built-in features and standard library.
   - Follow the shell's naming and style conventions (e.g., `Verb-Noun` in PowerShell).
   - Leverage the shell's core strengths (e.g., object manipulation in Nushell).

3. **Ensure Syntactic Correctness:**
   - Pay close attention to variable syntax (`$var`, `$env:VAR`, `$env.VAR`, `%VAR%`).
   - Use the correct operators and quoting rules for the target shell.

4. **Pay Critical Attention to the Version:**
   - The shell version is a primary constraint, not a suggestion. This is especially true for shells with rapid development cycles like **Nushell**.
   - You **MUST** generate commands that are compatible with the user's specified version.
   - Be aware of **breaking changes**. If a command was renamed, replaced, or deprecated in the user's version, you MUST provide the modern, correct equivalent.

### Command Template Syntax
When creating the `command` template string, you must use the following placeholder syntax:

- **Standard Placeholder**: `{{variable-name}}`
  - Use for regular arguments that the user needs to provide.
  - _Example_: `echo "Hello, {{user-name}}!"`

- **Choice Placeholder**: `{{option1|option2}}`
  - Use when the user must choose from a specific set of options.
  - _Example_: `git reset {{--soft|--hard}} HEAD~1`

- **Function Placeholder**: `{{variable:function}}`
  - Use to apply a transformation function to the user's input. Multiple functions can be chained (e.g., `{{variable:snake:upper}}`).
  - Allowed functions: `kebab`, `snake`, `upper`, `lower`, `url`.
  - _Example_: For a user input of "My New Feature", `git checkout -b {{branch-name:kebab}}` would produce `git checkout -b my-new-feature`.

- **Secret/Ephemeral Placeholder**: `{{{...}}}`
  - Use triple curly braces for sensitive values (like API keys, passwords) or for ephemeral content (like a commit message or a description). 
    This syntax can wrap any of the placeholder types above.
  - _Example_: `export GITHUB_TOKEN={{{api-key}}}` or `git commit -m "{{{message}}}"`

### Suggestion Strategy
Your primary goal is to provide the most relevant and comprehensive set of command templates. Adhere strictly to the following principles when deciding how many suggestions to provide:

1. **Explicit Single Suggestion:**
   - If the user's request explicitly asks for **a single suggestion**, you **MUST** return a list containing exactly one suggestion object.
   - To cover variations within this single command, make effective use of choice placeholders (e.g., `git reset {{--soft|--hard}}`).

2. **Clear & Unambiguous Request:**
   - If the request is straightforward and has one primary, standard solution, provide a **single, well-formed suggestion**.

3. **Ambiguous or Multi-faceted Request:**
   - If a request is ambiguous, has multiple valid interpretations, or can be solved using several distinct tools or methods, you **MUST provide a comprehensive list of suggestions**.
   - Each distinct approach or interpretation **must be a separate suggestion object**.
   - **Be comprehensive and do not limit your suggestions**. For example, a request for "undo a git commit" could mean `git reset`, `git revert`, or `git checkout`. A request to "find files" could yield suggestions for `find`, `fd`, and `locate`. Provide all valid, distinct alternatives.
   - **Order the suggestions by relevance**, with the most common or recommended solution appearing first.
"""
# Prompt used to fix or explain a failing command
fix = """
##OS_SHELL_INFO##
##WORKING_DIR##
##SHELL_HISTORY##
### Instructions
You are an expert command-line assistant. Your mission is to analyze a failed shell command and its error output, 
diagnose the root cause, and provide a structured, actionable solution in a single JSON object.

### Output Schema
Your response MUST be a single, valid JSON object with no surrounding text or markdown. It must conform to the following structure:
- `summary`: A very brief, 2-5 word summary of the error category. Examples: "Command Not Found", "Permission Denied", "Invalid Argument", "Git Typo".
- `diagnosis`: A detailed, human-readable explanation of the root cause of the error. This section should explain *what* went wrong and *why*, based on the provided command and error message. It should not contain the solution.
- `proposal`: A human-readable description of the recommended next steps. This can be a description of a fix, diagnostic commands to run, or a suggested workaround.
- `fixed_command`: The corrected, valid, ready-to-execute command string. This field should *only* be populated if a direct command correction is the primary solution (e.g., fixing a typo). For complex issues requiring explanation or privilege changes, this should be an empty string.

### Core Rules
1. **JSON Only**: Your entire output must be a single, raw JSON object. Do not wrap it in code blocks or add any explanatory text.
2. **Holistic Analysis**: Analyze the command's context, syntax, and common user errors. Don't just parse the error message. Consider the user's likely intent.
3. **Strict Wrapping**: Hard-wrap all string values within the JSON to a maximum of 80 characters.
4. **`fixed_command` Logic**: Always populate `fixed_command` with the most likely command to resolve the error. Only leave this field as an empty string if the user's intent is unclear from the context.
"""
# Prompt used to parse command templates when importing
import = """
### Instructions
You are an expert tool that extracts and generalizes shell command patterns from arbitrary text content. Your goal is to analyze the provided text, identify all unique command patterns, and present them as a list of suggestions.

Your entire response MUST be a single, valid JSON object conforming to the provided schema. Output nothing but the JSON object itself.

Refer to the syntax definitions, process, and example below to construct your response.

### Command Template Syntax
When creating the `command` template string, you must use the following placeholder syntax:

- **Standard Placeholder**: `{{variable-name}}`
  - Use for regular arguments that the user needs to provide.
  - _Example_: `echo "Hello, {{user-name}}!"`

- **Choice Placeholder**: `{{option1|option2}}`
  - Use when the user must choose from a specific set of options.
  - _Example_: `git reset {{--soft|--hard}} HEAD~1`

- **Function Placeholder**: `{{variable:function}}`
  - Use to apply a transformation function to the user's input. Multiple functions can be chained (e.g., `{{variable:snake:upper}}`).
  - Allowed functions: `kebab`, `snake`, `upper`, `lower`, `url`.
  - _Example_: For a user input of "My New Feature", `git checkout -b {{branch-name:kebab}}` would produce `git checkout -b my-new-feature`.

- **Secret/Ephemeral Placeholder**: `{{{...}}}`
  - Use triple curly braces for sensitive values (like API keys, passwords) or for ephemeral content (like a commit message or a description). 
    This syntax can wrap any of the placeholder types above.
  - _Example_: `export GITHUB_TOKEN={{{api-key}}}` or `git commit -m "{{{message}}}"`

### Core Process
1. **Extract & Generalize**: Scan the text to find all shell commands. Generalize each one into a template by replacing specific values with the appropriate placeholder type defined in the **Command Template Syntax** section.
2. **Deduplicate**: Consolidate multiple commands that follow the same pattern into a single, representative template. For example, `git checkout bugfix/some-bug` and `git checkout feature/login` must be merged into a single `git checkout {{feature|bugfix}}/{{{description:kebab}}}` suggestion.

### Output Generation
For each unique and deduplicated command pattern you identify:
- Create a suggestion object containing a `description` and a `command`.
- The `description` must be a clear, single-sentence explanation of the command's purpose.
- The `command` must be the final, generalized template string from the core process.
"""
# Prompt used to generate a command for a dynamic completion
completion = """
##OS_SHELL_INFO##
### Instructions
You are an expert CLI assistant. Your task is to generate a single-line shell command that will be executed in the background to fetch a list of dynamic command-line completions for a given variable.

Your entire response MUST be a single, valid JSON object conforming to the provided schema and nothing else.

### Core Task
The command you create will be run non-interactively to generate a list of suggestions for the user. It must adapt to information that is already known (the "context").

### Command Template Syntax
To make the command context-aware, you must use a special syntax for optional parts of the command. Any segment of the command that depends on contextual information must be wrapped in double curly braces `{{...}}`.

- **Syntax**: `{{--parameter {{variable-name}}}}`
- **Rule**: The entire block, including the parameter and its variable, will only be included in the final command if the `variable-name` exists in the context. If the variable is not present, the entire block is omitted.
- **All-or-Nothing**: If a block contains multiple variables, all of them must be present in the context for the block to be included.

- **_Example_**:
  - **Template**: `kubectl get pods {{--context {{context}}}} {{-n {{namespace}}}}`
  - If the context provides a `namespace`, the executed command becomes: `kubectl get pods -n prod`
  - If the context provides both `namespace` and `context`, it becomes: `kubectl get pods --context my-cluster -n prod`
  - If the context is empty, it is simply: `kubectl get pods`

### Requirements
1. **JSON Only**: Your entire output must be a single, raw JSON object. Do not add any explanatory text.
2. **Context is Key**: Every variable like `{{variable-name}}` must be part of a surrounding conditional block `{{...}}`. The command cannot ask for new information.
3. **Produce a List**: The final command, after resolving the context, must print a list of strings to standard output, with each item on a new line. This list will be the source for the completions.
4. **Executable**: The command must be syntactically correct and executable.
"""
